<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RadioLib: Si443x Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RadioLib
   </div>
   <div id="projectbrief">Universal wireless communication library for Arduino</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_si443x.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_si443x-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Si443x Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for <a class="el" href="class_si443x.html" title="Base class for Si443x series. All derived classes for Si443x (e.g. Si4431 or Si4432) inherit from thi...">Si443x</a> series. All derived classes for <a class="el" href="class_si443x.html" title="Base class for Si443x series. All derived classes for Si443x (e.g. Si4431 or Si4432) inherit from thi...">Si443x</a> (e.g. <a class="el" href="class_si4431.html" title="Derived class for Si4431 modules.">Si4431</a> or <a class="el" href="class_si4432.html" title="Derived class for Si4432 modules.">Si4432</a>) inherit from this base class. This class should not be instantiated directly from Arduino sketch, only from its derived classes.  
 <a href="class_si443x.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_si443x_8h_source.html">Si443x.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Si443x:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_si443x.png" usemap="#Si443x_map" alt=""/>
  <map id="Si443x_map" name="Si443x_map">
<area href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN...." alt="PhysicalLayer" shape="rect" coords="51,0,144,24"/>
<area href="class_si4432.html" title="Derived class for Si4432 modules." alt="Si4432" shape="rect" coords="51,112,144,136"/>
<area href="class_si4430.html" title="Derived class for Si4430 modules." alt="Si4430" shape="rect" coords="0,168,93,192"/>
<area href="class_si4431.html" title="Derived class for Si4431 modules." alt="Si4431" shape="rect" coords="103,168,196,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae7cfff2efebfa01c8a50a5cbbe8775b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#ae7cfff2efebfa01c8a50a5cbbe8775b9">Si443x</a> (<a class="el" href="class_module.html">Module</a> *mod)</td></tr>
<tr class="memdesc:ae7cfff2efebfa01c8a50a5cbbe8775b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="class_si443x.html#ae7cfff2efebfa01c8a50a5cbbe8775b9">More...</a><br /></td></tr>
<tr class="separator:ae7cfff2efebfa01c8a50a5cbbe8775b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427f24f614f04e87094354047bf1bf00"><td class="memItemLeft" align="right" valign="top"><a id="a427f24f614f04e87094354047bf1bf00"></a>
<a class="el" href="class_module.html">Module</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getMod</b> ()</td></tr>
<tr class="separator:a427f24f614f04e87094354047bf1bf00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453eda5436dc4dfe0dad676dc3977752"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a453eda5436dc4dfe0dad676dc3977752">begin</a> (float br, float freqDev, float rxBw, uint8_t preambleLen)</td></tr>
<tr class="memdesc:a453eda5436dc4dfe0dad676dc3977752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method.  <a href="class_si443x.html#a453eda5436dc4dfe0dad676dc3977752">More...</a><br /></td></tr>
<tr class="separator:a453eda5436dc4dfe0dad676dc3977752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae782ee06e2c463c24f22f5d4c3dd8d97"><td class="memItemLeft" align="right" valign="top"><a id="ae782ee06e2c463c24f22f5d4c3dd8d97"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#ae782ee06e2c463c24f22f5d4c3dd8d97">reset</a> ()</td></tr>
<tr class="memdesc:ae782ee06e2c463c24f22f5d4c3dd8d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset method. Will reset the chip to the default state using SDN pin. <br /></td></tr>
<tr class="separator:ae782ee06e2c463c24f22f5d4c3dd8d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782748025e19ec6e597293afb6570bff"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a782748025e19ec6e597293afb6570bff">transmit</a> (uint8_t *data, size_t len, uint8_t addr=0) override</td></tr>
<tr class="memdesc:a782748025e19ec6e597293afb6570bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary transmit method. Will transmit arbitrary binary data up to 64 bytes long. For overloads to transmit Arduino String or C-string, see <a class="el" href="class_physical_layer.html#a492b2d057dd803c3884fa1adc8e22534" title="C-string transmit method.">PhysicalLayer::transmit</a>.  <a href="class_si443x.html#a782748025e19ec6e597293afb6570bff">More...</a><br /></td></tr>
<tr class="separator:a782748025e19ec6e597293afb6570bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabca3ba8eda212938febab1df2e764b4"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#aabca3ba8eda212938febab1df2e764b4">receive</a> (uint8_t *data, size_t len) override</td></tr>
<tr class="memdesc:aabca3ba8eda212938febab1df2e764b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary receive method. Will attempt to receive arbitrary binary data up to 64 bytes long. For overloads to receive Arduino String, see <a class="el" href="class_physical_layer.html#ab82617fa3fa9f21d4cd427314ecc4af8" title="Binary receive method. Must be implemented in module class.">PhysicalLayer::receive</a>.  <a href="class_si443x.html#aabca3ba8eda212938febab1df2e764b4">More...</a><br /></td></tr>
<tr class="separator:aabca3ba8eda212938febab1df2e764b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada90718aeb67d7f0e9899da534de9695"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#ada90718aeb67d7f0e9899da534de9695">sleep</a> ()</td></tr>
<tr class="memdesc:ada90718aeb67d7f0e9899da534de9695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module to sleep to save power. Module will not be able to transmit or receive any data while in sleep mode. Module will wake up automatically when methods like transmit or receive are called.  <a href="class_si443x.html#ada90718aeb67d7f0e9899da534de9695">More...</a><br /></td></tr>
<tr class="separator:ada90718aeb67d7f0e9899da534de9695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45d2776df3ff338db154ead143fb7b8"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#ac45d2776df3ff338db154ead143fb7b8">standby</a> () override</td></tr>
<tr class="memdesc:ac45d2776df3ff338db154ead143fb7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module to standby (with XTAL on).  <a href="class_si443x.html#ac45d2776df3ff338db154ead143fb7b8">More...</a><br /></td></tr>
<tr class="separator:ac45d2776df3ff338db154ead143fb7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc0f95f32ca961294666405596ff529"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#acbc0f95f32ca961294666405596ff529">standby</a> (uint8_t mode) override</td></tr>
<tr class="memdesc:acbc0f95f32ca961294666405596ff529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module to standby.  <a href="class_si443x.html#acbc0f95f32ca961294666405596ff529">More...</a><br /></td></tr>
<tr class="separator:acbc0f95f32ca961294666405596ff529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a86a2032c4b876c1c8e4a7cf4730c99"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a5a86a2032c4b876c1c8e4a7cf4730c99">transmitDirect</a> (uint32_t frf=0) override</td></tr>
<tr class="memdesc:a5a86a2032c4b876c1c8e4a7cf4730c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables direct transmission mode. While in direct mode, the module will not be able to transmit or receive packets.  <a href="class_si443x.html#a5a86a2032c4b876c1c8e4a7cf4730c99">More...</a><br /></td></tr>
<tr class="separator:a5a86a2032c4b876c1c8e4a7cf4730c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178b471527813a608c04db7d3c9648d6"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a178b471527813a608c04db7d3c9648d6">receiveDirect</a> () override</td></tr>
<tr class="memdesc:a178b471527813a608c04db7d3c9648d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables direct reception mode. While in direct mode, the module will not be able to transmit or receive packets.  <a href="class_si443x.html#a178b471527813a608c04db7d3c9648d6">More...</a><br /></td></tr>
<tr class="separator:a178b471527813a608c04db7d3c9648d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616eb24c4b11c5d39caaade160be8092"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a616eb24c4b11c5d39caaade160be8092">packetMode</a> ()</td></tr>
<tr class="memdesc:a616eb24c4b11c5d39caaade160be8092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables direct mode and enables packet mode, allowing the module to receive packets.  <a href="class_si443x.html#a616eb24c4b11c5d39caaade160be8092">More...</a><br /></td></tr>
<tr class="separator:a616eb24c4b11c5d39caaade160be8092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801b51059e61f93d4e01ae6ba8eb0726"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a801b51059e61f93d4e01ae6ba8eb0726">setIrqAction</a> (void(*func)(void))</td></tr>
<tr class="memdesc:a801b51059e61f93d4e01ae6ba8eb0726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when IRQ activates.  <a href="class_si443x.html#a801b51059e61f93d4e01ae6ba8eb0726">More...</a><br /></td></tr>
<tr class="separator:a801b51059e61f93d4e01ae6ba8eb0726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d019f58551346c3f3bd8b72d2486109"><td class="memItemLeft" align="right" valign="top"><a id="a8d019f58551346c3f3bd8b72d2486109"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a8d019f58551346c3f3bd8b72d2486109">clearIrqAction</a> ()</td></tr>
<tr class="memdesc:a8d019f58551346c3f3bd8b72d2486109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when IRQ activates. <br /></td></tr>
<tr class="separator:a8d019f58551346c3f3bd8b72d2486109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402b4f5f11ba79e9cd4fb6ac0bfd9314"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a402b4f5f11ba79e9cd4fb6ac0bfd9314">startTransmit</a> (uint8_t *data, size_t len, uint8_t addr=0) override</td></tr>
<tr class="memdesc:a402b4f5f11ba79e9cd4fb6ac0bfd9314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven binary transmit method. Will start transmitting arbitrary binary data up to 64 bytes long.  <a href="class_si443x.html#a402b4f5f11ba79e9cd4fb6ac0bfd9314">More...</a><br /></td></tr>
<tr class="separator:a402b4f5f11ba79e9cd4fb6ac0bfd9314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6792f13441a1bbb3340d2ba3d9abbec3"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a6792f13441a1bbb3340d2ba3d9abbec3">finishTransmit</a> () override</td></tr>
<tr class="memdesc:a6792f13441a1bbb3340d2ba3d9abbec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after transmission is done.  <a href="class_si443x.html#a6792f13441a1bbb3340d2ba3d9abbec3">More...</a><br /></td></tr>
<tr class="separator:a6792f13441a1bbb3340d2ba3d9abbec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f886fc534a85bbf8c1aeb9b5ffe4f2"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a10f886fc534a85bbf8c1aeb9b5ffe4f2">startReceive</a> ()</td></tr>
<tr class="memdesc:a10f886fc534a85bbf8c1aeb9b5ffe4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven receive method. IRQ will be activated when full valid packet is received.  <a href="class_si443x.html#a10f886fc534a85bbf8c1aeb9b5ffe4f2">More...</a><br /></td></tr>
<tr class="separator:a10f886fc534a85bbf8c1aeb9b5ffe4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1070a6cde04a01d4a35da670f65ce539"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a1070a6cde04a01d4a35da670f65ce539">startReceive</a> (uint32_t timeout, uint16_t irqFlags, uint16_t irqMask, size_t len)</td></tr>
<tr class="memdesc:a1070a6cde04a01d4a35da670f65ce539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven receive method, implemented for compatibility with <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>.  <a href="class_si443x.html#a1070a6cde04a01d4a35da670f65ce539">More...</a><br /></td></tr>
<tr class="separator:a1070a6cde04a01d4a35da670f65ce539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00ff8b58c68118ad74fee82028aa71e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#ad00ff8b58c68118ad74fee82028aa71e">readData</a> (uint8_t *data, size_t len) override</td></tr>
<tr class="memdesc:ad00ff8b58c68118ad74fee82028aa71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data that was received after calling startReceive method. This method reads len characters.  <a href="class_si443x.html#ad00ff8b58c68118ad74fee82028aa71e">More...</a><br /></td></tr>
<tr class="separator:ad00ff8b58c68118ad74fee82028aa71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43575e731dd7e66d5ad9e6dccd27170"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#ad43575e731dd7e66d5ad9e6dccd27170">setBitRate</a> (float br)</td></tr>
<tr class="memdesc:ad43575e731dd7e66d5ad9e6dccd27170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK bit rate. Allowed values range from 0.123 to 256.0 kbps.  <a href="class_si443x.html#ad43575e731dd7e66d5ad9e6dccd27170">More...</a><br /></td></tr>
<tr class="separator:ad43575e731dd7e66d5ad9e6dccd27170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4e6caa95e5622f6f515ba0339a1c66"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a7c4e6caa95e5622f6f515ba0339a1c66">setFrequencyDeviation</a> (float freqDev) override</td></tr>
<tr class="memdesc:a7c4e6caa95e5622f6f515ba0339a1c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK frequency deviation from carrier frequency. Allowed values range from 0.625 to 320.0 kHz.  <a href="class_si443x.html#a7c4e6caa95e5622f6f515ba0339a1c66">More...</a><br /></td></tr>
<tr class="separator:a7c4e6caa95e5622f6f515ba0339a1c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e6b7c677e82042224798114f311175"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a51e6b7c677e82042224798114f311175">setRxBandwidth</a> (float rxBw)</td></tr>
<tr class="memdesc:a51e6b7c677e82042224798114f311175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets receiver bandwidth. Allowed values range from 2.6 to 620.7 kHz.  <a href="class_si443x.html#a51e6b7c677e82042224798114f311175">More...</a><br /></td></tr>
<tr class="separator:a51e6b7c677e82042224798114f311175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed0da298c2418db4a88a19ef8938e0a"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a4ed0da298c2418db4a88a19ef8938e0a">setSyncWord</a> (uint8_t *syncWord, size_t len)</td></tr>
<tr class="memdesc:a4ed0da298c2418db4a88a19ef8938e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets sync word. Up to 4 bytes can be set as sync word.  <a href="class_si443x.html#a4ed0da298c2418db4a88a19ef8938e0a">More...</a><br /></td></tr>
<tr class="separator:a4ed0da298c2418db4a88a19ef8938e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4821a6141caf16141074615c976ecd91"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a4821a6141caf16141074615c976ecd91">setPreambleLength</a> (uint8_t preambleLen)</td></tr>
<tr class="memdesc:a4821a6141caf16141074615c976ecd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets preamble length.  <a href="class_si443x.html#a4821a6141caf16141074615c976ecd91">More...</a><br /></td></tr>
<tr class="separator:a4821a6141caf16141074615c976ecd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d944669dc69ccd47f9e6c360f2ffd10"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a2d944669dc69ccd47f9e6c360f2ffd10">getPacketLength</a> (bool update=true) override</td></tr>
<tr class="memdesc:a2d944669dc69ccd47f9e6c360f2ffd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query modem for the packet length of received payload.  <a href="class_si443x.html#a2d944669dc69ccd47f9e6c360f2ffd10">More...</a><br /></td></tr>
<tr class="separator:a2d944669dc69ccd47f9e6c360f2ffd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1382fc3b68f447e381613e6670747128"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a1382fc3b68f447e381613e6670747128">setEncoding</a> (uint8_t encoding) override</td></tr>
<tr class="memdesc:a1382fc3b68f447e381613e6670747128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets transmission encoding. Only available in FSK mode. Allowed values are RADIOLIB_ENCODING_NRZ, RADIOLIB_ENCODING_MANCHESTER and RADIOLIB_ENCODING_WHITENING.  <a href="class_si443x.html#a1382fc3b68f447e381613e6670747128">More...</a><br /></td></tr>
<tr class="separator:a1382fc3b68f447e381613e6670747128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade08c79074c7e4414d34eefa25cee168"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#ade08c79074c7e4414d34eefa25cee168">setDataShaping</a> (uint8_t sh) override</td></tr>
<tr class="memdesc:ade08c79074c7e4414d34eefa25cee168"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Gaussian filter bandwidth-time product that will be used for data shaping. Only available in FSK mode with FSK modulation. Allowed values are RADIOLIB_SHAPING_0_5 or RADIOLIB_SHAPING_1_0. Set to RADIOLIB_SHAPING_NONE to disable data shaping.  <a href="class_si443x.html#ade08c79074c7e4414d34eefa25cee168">More...</a><br /></td></tr>
<tr class="separator:ade08c79074c7e4414d34eefa25cee168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e7ceeff9114b35ab89f1d69916b375"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a43e7ceeff9114b35ab89f1d69916b375">setRfSwitchPins</a> (uint32_t rxEn, uint32_t txEn)</td></tr>
<tr class="memdesc:a43e7ceeff9114b35ab89f1d69916b375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes: When idle both pins will be LOW, during TX the <code>txEn</code> pin will be HIGH, during RX the <code>rxPin</code> will be HIGH.  <a href="class_si443x.html#a43e7ceeff9114b35ab89f1d69916b375">More...</a><br /></td></tr>
<tr class="separator:a43e7ceeff9114b35ab89f1d69916b375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8898f11cf9dabd9a5ad717376fdbffa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a8898f11cf9dabd9a5ad717376fdbffa6">setRfSwitchTable</a> (const uint32_t(&amp;pins)[<a class="el" href="class_module.html#a0c11551e12579bbabf57b19e12555b3c">Module::RFSWITCH_MAX_PINS</a>], const <a class="el" href="struct_module_1_1_rf_switch_mode__t.html">Module::RfSwitchMode_t</a> table[])</td></tr>
<tr class="memdesc:a8898f11cf9dabd9a5ad717376fdbffa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes.  <a href="class_si443x.html#a8898f11cf9dabd9a5ad717376fdbffa6">More...</a><br /></td></tr>
<tr class="separator:a8898f11cf9dabd9a5ad717376fdbffa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74848176d435227e601c86ff37b0edbe"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a74848176d435227e601c86ff37b0edbe">randomByte</a> ()</td></tr>
<tr class="memdesc:a74848176d435227e601c86ff37b0edbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one truly random byte from RSSI noise.  <a href="class_si443x.html#a74848176d435227e601c86ff37b0edbe">More...</a><br /></td></tr>
<tr class="separator:a74848176d435227e601c86ff37b0edbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55252bda74e8c67636a8c1fa0e9f58d3"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a55252bda74e8c67636a8c1fa0e9f58d3">getChipVersion</a> ()</td></tr>
<tr class="memdesc:a55252bda74e8c67636a8c1fa0e9f58d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read version SPI register. Should return RADIOLIB_SI443X_DEVICE_VERSION (0x06) if <a class="el" href="class_si443x.html" title="Base class for Si443x series. All derived classes for Si443x (e.g. Si4431 or Si4432) inherit from thi...">Si443x</a> is connected and working.  <a href="class_si443x.html#a55252bda74e8c67636a8c1fa0e9f58d3">More...</a><br /></td></tr>
<tr class="separator:a55252bda74e8c67636a8c1fa0e9f58d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55fae20e81755c8b014d080741d61913"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a55fae20e81755c8b014d080741d61913">setDirectAction</a> (void(*func)(void))</td></tr>
<tr class="memdesc:a55fae20e81755c8b014d080741d61913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when data bit is receveid in direct mode.  <a href="class_si443x.html#a55fae20e81755c8b014d080741d61913">More...</a><br /></td></tr>
<tr class="separator:a55fae20e81755c8b014d080741d61913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23d8eb0f1c436e6cc60361df13c08f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#af23d8eb0f1c436e6cc60361df13c08f7">readBit</a> (uint32_t pin)</td></tr>
<tr class="memdesc:af23d8eb0f1c436e6cc60361df13c08f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to read and process data bit in direct reception mode.  <a href="class_si443x.html#af23d8eb0f1c436e6cc60361df13c08f7">More...</a><br /></td></tr>
<tr class="separator:af23d8eb0f1c436e6cc60361df13c08f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b3a961a99d9e8f3a7ead6e8b69e858"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#ad2b3a961a99d9e8f3a7ead6e8b69e858">fixedPacketLengthMode</a> (uint8_t len=RADIOLIB_SI443X_MAX_PACKET_LENGTH)</td></tr>
<tr class="memdesc:ad2b3a961a99d9e8f3a7ead6e8b69e858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem in fixed packet length mode.  <a href="class_si443x.html#ad2b3a961a99d9e8f3a7ead6e8b69e858">More...</a><br /></td></tr>
<tr class="separator:ad2b3a961a99d9e8f3a7ead6e8b69e858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcca8ab4a1229efb5e7c6b09e564a48a"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#abcca8ab4a1229efb5e7c6b09e564a48a">variablePacketLengthMode</a> (uint8_t maxLen=RADIOLIB_SI443X_MAX_PACKET_LENGTH)</td></tr>
<tr class="memdesc:abcca8ab4a1229efb5e7c6b09e564a48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem in variable packet length mode.  <a href="class_si443x.html#abcca8ab4a1229efb5e7c6b09e564a48a">More...</a><br /></td></tr>
<tr class="separator:abcca8ab4a1229efb5e7c6b09e564a48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492b2d057dd803c3884fa1adc8e22534"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a492b2d057dd803c3884fa1adc8e22534">transmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a492b2d057dd803c3884fa1adc8e22534"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-string transmit method.  <a href="class_si443x.html#a492b2d057dd803c3884fa1adc8e22534">More...</a><br /></td></tr>
<tr class="separator:a492b2d057dd803c3884fa1adc8e22534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd42f8d5569487ea74f004ca652a709"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a3dd42f8d5569487ea74f004ca652a709">transmit</a> (uint8_t *data, size_t len, uint8_t addr=0)</td></tr>
<tr class="memdesc:a3dd42f8d5569487ea74f004ca652a709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary transmit method. Must be implemented in module class.  <a href="class_si443x.html#a3dd42f8d5569487ea74f004ca652a709">More...</a><br /></td></tr>
<tr class="separator:a3dd42f8d5569487ea74f004ca652a709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82617fa3fa9f21d4cd427314ecc4af8"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#ab82617fa3fa9f21d4cd427314ecc4af8">receive</a> (uint8_t *data, size_t len)</td></tr>
<tr class="memdesc:ab82617fa3fa9f21d4cd427314ecc4af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary receive method. Must be implemented in module class.  <a href="class_si443x.html#ab82617fa3fa9f21d4cd427314ecc4af8">More...</a><br /></td></tr>
<tr class="separator:ab82617fa3fa9f21d4cd427314ecc4af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923654706eff5118ef6e84214e837f27"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a923654706eff5118ef6e84214e837f27">startTransmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a923654706eff5118ef6e84214e837f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <a href="class_si443x.html#a923654706eff5118ef6e84214e837f27">More...</a><br /></td></tr>
<tr class="separator:a923654706eff5118ef6e84214e837f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59e37ce0606dc8051e40be9d14cfec3"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#ad59e37ce0606dc8051e40be9d14cfec3">startTransmit</a> (uint8_t *data, size_t len, uint8_t addr=0)</td></tr>
<tr class="memdesc:ad59e37ce0606dc8051e40be9d14cfec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven binary transmit method.  <a href="class_si443x.html#ad59e37ce0606dc8051e40be9d14cfec3">More...</a><br /></td></tr>
<tr class="separator:ad59e37ce0606dc8051e40be9d14cfec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3563453988a83d22dd07d4691543a300"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_si443x.html#a3563453988a83d22dd07d4691543a300">readData</a> (uint8_t *data, size_t len)</td></tr>
<tr class="memdesc:a3563453988a83d22dd07d4691543a300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data that was received after calling startReceive method.  <a href="class_si443x.html#a3563453988a83d22dd07d4691543a300">More...</a><br /></td></tr>
<tr class="separator:a3563453988a83d22dd07d4691543a300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_physical_layer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_physical_layer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_physical_layer.html">PhysicalLayer</a></td></tr>
<tr class="memitem:add63d7d4fa8b14df5e185813794a49d5 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#add63d7d4fa8b14df5e185813794a49d5">PhysicalLayer</a> (float step, size_t maxLen)</td></tr>
<tr class="memdesc:add63d7d4fa8b14df5e185813794a49d5 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="class_physical_layer.html#add63d7d4fa8b14df5e185813794a49d5">More...</a><br /></td></tr>
<tr class="separator:add63d7d4fa8b14df5e185813794a49d5 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a492b2d057dd803c3884fa1adc8e22534">transmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-string transmit method.  <a href="class_physical_layer.html#a492b2d057dd803c3884fa1adc8e22534">More...</a><br /></td></tr>
<tr class="separator:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a923654706eff5118ef6e84214e837f27">startTransmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <a href="class_physical_layer.html#a923654706eff5118ef6e84214e837f27">More...</a><br /></td></tr>
<tr class="separator:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a194b0fbb66b1a953288bf3b9478d6e inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a8a194b0fbb66b1a953288bf3b9478d6e">setFrequency</a> (float freq)</td></tr>
<tr class="memdesc:a8a194b0fbb66b1a953288bf3b9478d6e inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets carrier frequency. Must be implemented in module class.  <a href="class_physical_layer.html#a8a194b0fbb66b1a953288bf3b9478d6e">More...</a><br /></td></tr>
<tr class="separator:a8a194b0fbb66b1a953288bf3b9478d6e inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977e5236693960bb1c79090a201e9e1c inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a977e5236693960bb1c79090a201e9e1c">getFreqStep</a> () const</td></tr>
<tr class="memdesc:a977e5236693960bb1c79090a201e9e1c inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the module frequency step size that was set in constructor.  <a href="class_physical_layer.html#a977e5236693960bb1c79090a201e9e1c">More...</a><br /></td></tr>
<tr class="separator:a977e5236693960bb1c79090a201e9e1c inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc94ab27a9ee6daaafa9b47dde5f75b inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#aabc94ab27a9ee6daaafa9b47dde5f75b">getRSSI</a> ()</td></tr>
<tr class="memdesc:aabc94ab27a9ee6daaafa9b47dde5f75b inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets RSSI (Recorded Signal Strength Indicator) of the last received packet.  <a href="class_physical_layer.html#aabc94ab27a9ee6daaafa9b47dde5f75b">More...</a><br /></td></tr>
<tr class="separator:aabc94ab27a9ee6daaafa9b47dde5f75b inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedddaf9460941b90e43e9005035faa0f inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#aedddaf9460941b90e43e9005035faa0f">getSNR</a> ()</td></tr>
<tr class="memdesc:aedddaf9460941b90e43e9005035faa0f inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets SNR (Signal to Noise Ratio) of the last received packet. Only available for LoRa modem.  <a href="class_physical_layer.html#aedddaf9460941b90e43e9005035faa0f">More...</a><br /></td></tr>
<tr class="separator:aedddaf9460941b90e43e9005035faa0f inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#acd9171bd71aa80fb86113b612c42de53">random</a> (int32_t max)</td></tr>
<tr class="memdesc:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get truly random number in range 0 - max.  <a href="class_physical_layer.html#acd9171bd71aa80fb86113b612c42de53">More...</a><br /></td></tr>
<tr class="separator:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a76113e10481743094a1cd0280692b0a9">random</a> (int32_t min, int32_t max)</td></tr>
<tr class="memdesc:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get truly random number in range min - max.  <a href="class_physical_layer.html#a76113e10481743094a1cd0280692b0a9">More...</a><br /></td></tr>
<tr class="separator:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a88a10657bd2215a11a2331f937414b55">startDirect</a> ()</td></tr>
<tr class="memdesc:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure module parameters for direct modes. Must be called prior to "ham" modes like RTTY or AX.25. Only available in FSK mode.  <a href="class_physical_layer.html#a88a10657bd2215a11a2331f937414b55">More...</a><br /></td></tr>
<tr class="separator:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a8e378fe136a498ea485a9c10f5e15aab">setDirectSyncWord</a> (uint32_t syncWord, uint8_t len)</td></tr>
<tr class="memdesc:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set sync word to be used to determine start of packet in direct reception mode.  <a href="class_physical_layer.html#a8e378fe136a498ea485a9c10f5e15aab">More...</a><br /></td></tr>
<tr class="separator:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ab57182d32646861ef0d865e2740d6b26">available</a> ()</td></tr>
<tr class="memdesc:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of direct mode bytes currently available in buffer.  <a href="class_physical_layer.html#ab57182d32646861ef0d865e2740d6b26">More...</a><br /></td></tr>
<tr class="separator:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429796eb2e7ea86781a2e8ca42af43f3 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top"><a id="a429796eb2e7ea86781a2e8ca42af43f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a429796eb2e7ea86781a2e8ca42af43f3">dropSync</a> ()</td></tr>
<tr class="memdesc:a429796eb2e7ea86781a2e8ca42af43f3 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forcefully drop synchronization. <br /></td></tr>
<tr class="separator:a429796eb2e7ea86781a2e8ca42af43f3 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5b30493c8d7fcfb784e128362d596c inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a4d5b30493c8d7fcfb784e128362d596c">read</a> (bool drop=true)</td></tr>
<tr class="memdesc:a4d5b30493c8d7fcfb784e128362d596c inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data from direct mode buffer.  <a href="class_physical_layer.html#a4d5b30493c8d7fcfb784e128362d596c">More...</a><br /></td></tr>
<tr class="separator:a4d5b30493c8d7fcfb784e128362d596c inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349e8a22cd28ad89d45460fdeeefc05c inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a349e8a22cd28ad89d45460fdeeefc05c">setDIOMapping</a> (uint32_t pin, uint32_t value)</td></tr>
<tr class="memdesc:a349e8a22cd28ad89d45460fdeeefc05c inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure DIO pin mapping to get a given signal on a DIO pin (if available).  <a href="class_physical_layer.html#a349e8a22cd28ad89d45460fdeeefc05c">More...</a><br /></td></tr>
<tr class="separator:a349e8a22cd28ad89d45460fdeeefc05c inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c0beb4990876947f746751d45ac41d inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a63c0beb4990876947f746751d45ac41d">setDio1Action</a> (void(*func)(void))</td></tr>
<tr class="memdesc:a63c0beb4990876947f746751d45ac41d inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when DIO1 activates.  <a href="class_physical_layer.html#a63c0beb4990876947f746751d45ac41d">More...</a><br /></td></tr>
<tr class="separator:a63c0beb4990876947f746751d45ac41d inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30127e094d8148870b9631007ec6b29 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top"><a id="ad30127e094d8148870b9631007ec6b29"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ad30127e094d8148870b9631007ec6b29">clearDio1Action</a> ()</td></tr>
<tr class="memdesc:ad30127e094d8148870b9631007ec6b29 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when DIO1 activates. <br /></td></tr>
<tr class="separator:ad30127e094d8148870b9631007ec6b29 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for <a class="el" href="class_si443x.html" title="Base class for Si443x series. All derived classes for Si443x (e.g. Si4431 or Si4432) inherit from thi...">Si443x</a> series. All derived classes for <a class="el" href="class_si443x.html" title="Base class for Si443x series. All derived classes for Si443x (e.g. Si4431 or Si4432) inherit from thi...">Si443x</a> (e.g. <a class="el" href="class_si4431.html" title="Derived class for Si4431 modules.">Si4431</a> or <a class="el" href="class_si4432.html" title="Derived class for Si4432 modules.">Si4432</a>) inherit from this base class. This class should not be instantiated directly from Arduino sketch, only from its derived classes. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae7cfff2efebfa01c8a50a5cbbe8775b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7cfff2efebfa01c8a50a5cbbe8775b9">&#9670;&nbsp;</a></span>Si443x()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Si443x::Si443x </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>Instance of <a class="el" href="class_module.html" title="Implements all common low-level methods to control the wireless module. Every module class contains o...">Module</a> that will be used to communicate with the radio. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a453eda5436dc4dfe0dad676dc3977752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453eda5436dc4dfe0dad676dc3977752">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::begin </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>br</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freqDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rxBw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>preambleLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">br</td><td>Bit rate of the FSK transmission in kbps (kilobits per second). </td></tr>
    <tr><td class="paramname">freqDev</td><td>Frequency deviation of the FSK transmission in kHz. </td></tr>
    <tr><td class="paramname">rxBw</td><td>Receiver bandwidth in kHz. </td></tr>
    <tr><td class="paramname">preambleLen</td><td>Preamble Length in bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a6792f13441a1bbb3340d2ba3d9abbec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6792f13441a1bbb3340d2ba3d9abbec3">&#9670;&nbsp;</a></span>finishTransmit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::finishTransmit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clean up after transmission is done. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a1de26f68b939f5af79ec29cc34c7be18">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ad2b3a961a99d9e8f3a7ead6e8b69e858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b3a961a99d9e8f3a7ead6e8b69e858">&#9670;&nbsp;</a></span>fixedPacketLengthMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::fixedPacketLengthMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>RADIOLIB_SI443X_MAX_PACKET_LENGTH</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set modem in fixed packet length mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Packet length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a55252bda74e8c67636a8c1fa0e9f58d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55252bda74e8c67636a8c1fa0e9f58d3">&#9670;&nbsp;</a></span>getChipVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::getChipVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read version SPI register. Should return RADIOLIB_SI443X_DEVICE_VERSION (0x06) if <a class="el" href="class_si443x.html" title="Base class for Si443x series. All derived classes for Si443x (e.g. Si4431 or Si4432) inherit from thi...">Si443x</a> is connected and working. </p>
<dl class="section return"><dt>Returns</dt><dd>Version register contents or <a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a2d944669dc69ccd47f9e6c360f2ffd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d944669dc69ccd47f9e6c360f2ffd10">&#9670;&nbsp;</a></span>getPacketLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Si443x::getPacketLength </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query modem for the packet length of received payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>Update received packet length. Will return cached value when set to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of last received packet in bytes. </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a2fe95169b5cdc8cabe1f2af66cad6ef6">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a616eb24c4b11c5d39caaade160be8092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616eb24c4b11c5d39caaade160be8092">&#9670;&nbsp;</a></span>packetMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::packetMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables direct mode and enables packet mode, allowing the module to receive packets. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a74848176d435227e601c86ff37b0edbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74848176d435227e601c86ff37b0edbe">&#9670;&nbsp;</a></span>randomByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Si443x::randomByte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get one truly random byte from RSSI noise. </p>
<dl class="section return"><dt>Returns</dt><dd>TRNG byte. </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a1a5985308904261dd431f373d47ddee4">PhysicalLayer</a>.</p>

</div>
</div>
<a id="af23d8eb0f1c436e6cc60361df13c08f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23d8eb0f1c436e6cc60361df13c08f7">&#9670;&nbsp;</a></span>readBit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Si443x::readBit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to read and process data bit in direct reception mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Pin on which to read. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#acda61fc99cfa373153c50c78380ed885">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a3563453988a83d22dd07d4691543a300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3563453988a83d22dd07d4691543a300">&#9670;&nbsp;</a></span>readData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::readData</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data that was received after calling startReceive method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be read. When set to 0, the packet length will be retreived automatically. When more bytes than received are requested, only the number of bytes requested will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ad00ff8b58c68118ad74fee82028aa71e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00ff8b58c68118ad74fee82028aa71e">&#9670;&nbsp;</a></span>readData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::readData </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data that was received after calling startReceive method. This method reads len characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be read. When set to 0, the packet length will be retreived automatically. When more bytes than received are requested, only the number of bytes requested will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a3563453988a83d22dd07d4691543a300">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ab82617fa3fa9f21d4cd427314ecc4af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82617fa3fa9f21d4cd427314ecc4af8">&#9670;&nbsp;</a></span>receive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::receive</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary receive method. Must be implemented in module class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be received. Must be known in advance for binary transmissions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="aabca3ba8eda212938febab1df2e764b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabca3ba8eda212938febab1df2e764b4">&#9670;&nbsp;</a></span>receive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::receive </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary receive method. Will attempt to receive arbitrary binary data up to 64 bytes long. For overloads to receive Arduino String, see <a class="el" href="class_physical_layer.html#ab82617fa3fa9f21d4cd427314ecc4af8" title="Binary receive method. Must be implemented in module class.">PhysicalLayer::receive</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be received. Must be known in advance for binary transmissions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ab82617fa3fa9f21d4cd427314ecc4af8">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a178b471527813a608c04db7d3c9648d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178b471527813a608c04db7d3c9648d6">&#9670;&nbsp;</a></span>receiveDirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::receiveDirect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables direct reception mode. While in direct mode, the module will not be able to transmit or receive packets. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ad9d1dbb2041e87af5a80e12f125a60e6">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ad43575e731dd7e66d5ad9e6dccd27170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43575e731dd7e66d5ad9e6dccd27170">&#9670;&nbsp;</a></span>setBitRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::setBitRate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>br</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets FSK bit rate. Allowed values range from 0.123 to 256.0 kbps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">br</td><td>Bit rate to be set (in kbps). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aedd39ad84b45c6392087b12d59192d8c">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ade08c79074c7e4414d34eefa25cee168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade08c79074c7e4414d34eefa25cee168">&#9670;&nbsp;</a></span>setDataShaping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::setDataShaping </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets Gaussian filter bandwidth-time product that will be used for data shaping. Only available in FSK mode with FSK modulation. Allowed values are RADIOLIB_SHAPING_0_5 or RADIOLIB_SHAPING_1_0. Set to RADIOLIB_SHAPING_NONE to disable data shaping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sh</td><td>Gaussian shaping bandwidth-time product that will be used for data shaping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aeba04366a0cf05ff3d8227c4f7c8e1e9">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a55fae20e81755c8b014d080741d61913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55fae20e81755c8b014d080741d61913">&#9670;&nbsp;</a></span>setDirectAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Si443x::setDirectAction </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set interrupt service routine function to call when data bit is receveid in direct mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Pointer to interrupt service routine. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#abf96cf4f3cb4c82d44be581dbe615966">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a1382fc3b68f447e381613e6670747128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1382fc3b68f447e381613e6670747128">&#9670;&nbsp;</a></span>setEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::setEncoding </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>encoding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets transmission encoding. Only available in FSK mode. Allowed values are RADIOLIB_ENCODING_NRZ, RADIOLIB_ENCODING_MANCHESTER and RADIOLIB_ENCODING_WHITENING. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoding</td><td>Encoding to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd><ul>
<li>add inverted Manchester? </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#acb45b2342400a03a914a91d2ac7fb488">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a7c4e6caa95e5622f6f515ba0339a1c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4e6caa95e5622f6f515ba0339a1c66">&#9670;&nbsp;</a></span>setFrequencyDeviation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::setFrequencyDeviation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freqDev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets FSK frequency deviation from carrier frequency. Allowed values range from 0.625 to 320.0 kHz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freqDev</td><td>Frequency deviation to be set (in kHz). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a2f4f9b428d9ea9af886ca85e5088ed7b">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a801b51059e61f93d4e01ae6ba8eb0726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a801b51059e61f93d4e01ae6ba8eb0726">&#9670;&nbsp;</a></span>setIrqAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Si443x::setIrqAction </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets interrupt service routine to call when IRQ activates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>ISR to call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4821a6141caf16141074615c976ecd91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4821a6141caf16141074615c976ecd91">&#9670;&nbsp;</a></span>setPreambleLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::setPreambleLength </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>preambleLen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets preamble length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preambleLen</td><td>Preamble length to be set (in bits). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a43e7ceeff9114b35ab89f1d69916b375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e7ceeff9114b35ab89f1d69916b375">&#9670;&nbsp;</a></span>setRfSwitchPins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Si443x::setRfSwitchPins </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rxEn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>txEn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes: When idle both pins will be LOW, during TX the <code>txEn</code> pin will be HIGH, during RX the <code>rxPin</code> will be HIGH. </p>
<p>Radiolib will automatically set the pin mode and value of these pins, so do not control them from the sketch.</p>
<p>When more than two pins or more control over the output values are needed, use the <a class="el" href="class_si443x.html#a8898f11cf9dabd9a5ad717376fdbffa6" title="Some modules contain external RF switch controlled by pins. This function gives RadioLib control over...">setRfSwitchTable()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rxEn</td><td>RX enable pin. </td></tr>
    <tr><td class="paramname">txEn</td><td>TX enable pin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8898f11cf9dabd9a5ad717376fdbffa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8898f11cf9dabd9a5ad717376fdbffa6">&#9670;&nbsp;</a></span>setRfSwitchTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Si443x::setRfSwitchTable </td>
          <td>(</td>
          <td class="paramtype">const uint32_t(&amp;)&#160;</td>
          <td class="paramname"><em>pins</em>[Module::RFSWITCH_MAX_PINS], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_module_1_1_rf_switch_mode__t.html">Module::RfSwitchMode_t</a>&#160;</td>
          <td class="paramname"><em>table</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes. </p>
<p>Radiolib will automatically set the pin mode and value of these pins, so do not control them from the sketch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pins</td><td>A reference to an array of pins to control. This should always be an array of 3 elements. If you need less pins, use RADIOLIB_NC for the unused elements.</td></tr>
    <tr><td class="paramname">table</td><td>A reference to an array of pin values to use for each supported mode. Each element is an RfSwitchMode_T struct that lists the mode for which it applies and the values for each of the pins passed in the pins argument respectively.</td></tr>
  </table>
  </dd>
</dl>
<p>The <code>pins</code> array will be copied into the <a class="el" href="class_module.html" title="Implements all common low-level methods to control the wireless module. Every module class contains o...">Module</a> object, so the original array can be deallocated after this call. However, a reference to the <code>table</code> array will be stored, so that array must remain valid as long RadioLib is being used.</p>
<p>The <code>mode</code> field in each table row should normally use any of the <code>MODE_*</code> constants from the <a class="el" href="class_module.html#a5a67b3a63420d762ecba9448671c99bf">Module::OpMode_t</a> enum. However, some radios support additional modes and will define their own OpMode_t enum.</p>
<p>The length of the table is variable (to support radios that add additional modes), so the table must always be terminated with the special END_OF_MODE_TABLE value.</p>
<p>Normally all modes should be listed in the table, but for some radios, modes can be omitted to indicate they are not supported (e.g. when a radio has a high power and low power TX mode but external circuitry only supports low power). If applicable, this is documented in the radio class itself.</p>
<h4>Example</h4>
<p>For example, on a board that has an RF switch with an enable pin connected to PA0 and a TX/RX select pin connected to PA1:</p>
<div class="fragment"><div class="line"><span class="comment">// In global scope, define the pin array and mode table</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint32_t rfswitch_pins[] =</div>
<div class="line">                       {PA0,  PA1,  RADIOLIB_NC};</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="struct_module_1_1_rf_switch_mode__t.html">Module::RfSwitchMode_t</a> rfswitch_table[] = {</div>
<div class="line">  {<a class="code" href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa505acc66c5e0faa83d2216aca5f3e671">Module::MODE_IDLE</a>,  {LOW,  LOW}},</div>
<div class="line">  {<a class="code" href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa7664838bb0818663f55b3354fec8a18f">Module::MODE_RX</a>,    {HIGH, LOW}},</div>
<div class="line">  {<a class="code" href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa269f4bc8ba3eb3d8568feb7b2decf571">Module::MODE_TX</a>,    {HIGH, HIGH}},</div>
<div class="line">   Module::END_OF_MODE_TABLE,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> setup() {</div>
<div class="line">  ...</div>
<div class="line">  <span class="comment">// Then somewhere in setup, pass them to radiolib</span></div>
<div class="line">  radio.setRfSwitchTable(rfswitch_pins, rfswitch_table);</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="aclass_module_html_a5a67b3a63420d762ecba9448671c99bfa269f4bc8ba3eb3d8568feb7b2decf571"><div class="ttname"><a href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa269f4bc8ba3eb3d8568feb7b2decf571">Module::MODE_TX</a></div><div class="ttdeci">@ MODE_TX</div><div class="ttdef"><b>Definition:</b> Module.h:71</div></div>
<div class="ttc" id="aclass_module_html_a5a67b3a63420d762ecba9448671c99bfa505acc66c5e0faa83d2216aca5f3e671"><div class="ttname"><a href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa505acc66c5e0faa83d2216aca5f3e671">Module::MODE_IDLE</a></div><div class="ttdeci">@ MODE_IDLE</div><div class="ttdef"><b>Definition:</b> Module.h:67</div></div>
<div class="ttc" id="aclass_module_html_a5a67b3a63420d762ecba9448671c99bfa7664838bb0818663f55b3354fec8a18f"><div class="ttname"><a href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa7664838bb0818663f55b3354fec8a18f">Module::MODE_RX</a></div><div class="ttdeci">@ MODE_RX</div><div class="ttdef"><b>Definition:</b> Module.h:69</div></div>
<div class="ttc" id="astruct_module_1_1_rf_switch_mode__t_html"><div class="ttname"><a href="struct_module_1_1_rf_switch_mode__t.html">Module::RfSwitchMode_t</a></div><div class="ttdef"><b>Definition:</b> Module.h:49</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a51e6b7c677e82042224798114f311175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e6b7c677e82042224798114f311175">&#9670;&nbsp;</a></span>setRxBandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::setRxBandwidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rxBw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets receiver bandwidth. Allowed values range from 2.6 to 620.7 kHz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rxBw</td><td>Receiver bandwidth to be set in kHz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>float tolerance equality as macro? </dd></dl>

</div>
</div>
<a id="a4ed0da298c2418db4a88a19ef8938e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed0da298c2418db4a88a19ef8938e0a">&#9670;&nbsp;</a></span>setSyncWord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::setSyncWord </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>syncWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets sync word. Up to 4 bytes can be set as sync word. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syncWord</td><td>Pointer to the array of sync word bytes. </td></tr>
    <tr><td class="paramname">len</td><td>Sync word length in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada90718aeb67d7f0e9899da534de9695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada90718aeb67d7f0e9899da534de9695">&#9670;&nbsp;</a></span>sleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::sleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the module to sleep to save power. Module will not be able to transmit or receive any data while in sleep mode. Module will wake up automatically when methods like transmit or receive are called. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#af1bb9a5da26da8829795ebb72e9c666e">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ac45d2776df3ff338db154ead143fb7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45d2776df3ff338db154ead143fb7b8">&#9670;&nbsp;</a></span>standby() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::standby </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the module to standby (with XTAL on). </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#acbcaf6aefcb77a354797e66222fe5018">PhysicalLayer</a>.</p>

</div>
</div>
<a id="acbc0f95f32ca961294666405596ff529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbc0f95f32ca961294666405596ff529">&#9670;&nbsp;</a></span>standby() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::standby </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the module to standby. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Standby mode to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a7d5da4311092e3df6b193ff303a0c5e8">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a10f886fc534a85bbf8c1aeb9b5ffe4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f886fc534a85bbf8c1aeb9b5ffe4f2">&#9670;&nbsp;</a></span>startReceive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::startReceive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt-driven receive method. IRQ will be activated when full valid packet is received. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a1070a6cde04a01d4a35da670f65ce539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1070a6cde04a01d4a35da670f65ce539">&#9670;&nbsp;</a></span>startReceive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::startReceive </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>irqFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>irqMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt-driven receive method, implemented for compatibility with <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Ignored. </td></tr>
    <tr><td class="paramname">irqFlags</td><td>Ignored. </td></tr>
    <tr><td class="paramname">irqMask</td><td>Ignored. </td></tr>
    <tr><td class="paramname">len</td><td>Ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a13dbafeeb9dd9ede72cc4d907738ac48">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a923654706eff5118ef6e84214e837f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923654706eff5118ef6e84214e837f27">&#9670;&nbsp;</a></span>startTransmit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::startTransmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C-string that will be transmitted. </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ad59e37ce0606dc8051e40be9d14cfec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59e37ce0606dc8051e40be9d14cfec3">&#9670;&nbsp;</a></span>startTransmit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::startTransmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt-driven binary transmit method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data that will be transmitted. </td></tr>
    <tr><td class="paramname">len</td><td>Length of binary data to transmit (in bytes). </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a402b4f5f11ba79e9cd4fb6ac0bfd9314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402b4f5f11ba79e9cd4fb6ac0bfd9314">&#9670;&nbsp;</a></span>startTransmit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::startTransmit </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt-driven binary transmit method. Will start transmitting arbitrary binary data up to 64 bytes long. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data that will be transmitted. </td></tr>
    <tr><td class="paramname">len</td><td>Length of binary data to transmit (in bytes). </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>use header as address field? </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ad59e37ce0606dc8051e40be9d14cfec3">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a492b2d057dd803c3884fa1adc8e22534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492b2d057dd803c3884fa1adc8e22534">&#9670;&nbsp;</a></span>transmit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::transmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C-string transmit method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C-string that will be transmitted. </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a3dd42f8d5569487ea74f004ca652a709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd42f8d5569487ea74f004ca652a709">&#9670;&nbsp;</a></span>transmit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::transmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary transmit method. Must be implemented in module class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data that will be transmitted. </td></tr>
    <tr><td class="paramname">len</td><td>Length of binary data to transmit (in bytes). </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a782748025e19ec6e597293afb6570bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782748025e19ec6e597293afb6570bff">&#9670;&nbsp;</a></span>transmit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::transmit </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary transmit method. Will transmit arbitrary binary data up to 64 bytes long. For overloads to transmit Arduino String or C-string, see <a class="el" href="class_physical_layer.html#a492b2d057dd803c3884fa1adc8e22534" title="C-string transmit method.">PhysicalLayer::transmit</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data that will be transmitted. </td></tr>
    <tr><td class="paramname">len</td><td>Length of binary data to transmit (in bytes). </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a3dd42f8d5569487ea74f004ca652a709">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a5a86a2032c4b876c1c8e4a7cf4730c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a86a2032c4b876c1c8e4a7cf4730c99">&#9670;&nbsp;</a></span>transmitDirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::transmitDirect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frf</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables direct transmission mode. While in direct mode, the module will not be able to transmit or receive packets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frf</td><td>24-bit raw frequency value to start transmitting at. Required for quick frequency shifts in RTTY. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>integers only </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aa4c99ac794ee653c2061be4201724b65">PhysicalLayer</a>.</p>

</div>
</div>
<a id="abcca8ab4a1229efb5e7c6b09e564a48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcca8ab4a1229efb5e7c6b09e564a48a">&#9670;&nbsp;</a></span>variablePacketLengthMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Si443x::variablePacketLengthMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>maxLen</em> = <code>RADIOLIB_SI443X_MAX_PACKET_LENGTH</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set modem in variable packet length mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxLen</td><td>Maximum packet length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/modules/Si443x/<a class="el" href="_si443x_8h_source.html">Si443x.h</a></li>
<li>src/modules/Si443x/Si443x.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_si443x.html">Si443x</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
